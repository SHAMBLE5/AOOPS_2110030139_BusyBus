->Choose Any 2 structural patterns

1.Adapter
2.Facade

->List out Similarities and Diffrences

Similarities
1.All of them are defined as structural patterns.
2.Both Adapter and Facade pattern, forwards requests to a different interface
3.Adapter and Facade patterns is that they can wrap multiple interfaces
4.All of them uses Composition and delegation to fulfill there intent.

Differences
1.Adapter
.Provides differnet interface for an interface
.It allows you to enrich the object, even after its creation
.The Adapter Pattern lets two components working together, which wouldn't be working because of incompatible interfaces

2.Facade
.Simplifies multiple complex components with single interface
.Facade design pattern neither converts interfaces nor adds new functionality, instead, it just provides simpler interfaces.
.allows clients to interact with complex systems with a much simpler interface and less work. 

Participants

Adapter 

Target - defines the domain-specific interface that Client uses.
Adapter - adapts the interface Adaptee to the Target interface.
Adaptee - defines an existing interface that needs adapting.
Client - collaborates with objects conforming to the Target interface.

Facade

Facade (Compiler)
knows which subsystem classes are responsible for a request.
delegates client requests to appropriate subsystem objects.
subsystem classes (Scanner, Parser, ProgramNode, etc.)
implement subsystem functionality.
handle work assigned by the Facade object.
have no knowledge of the facade; that is, they keep no references to it.

Examples

Adapter

Scenario 
          Adjusting the voltage

package Structural_Pattern;
interface power{
  
  public void powersupply();
}

class powerSupply implements power{
  
  int powervolt;
  public void powersupply()
  {
    powervolt=220;
  }
}
class powerAdapter extends powerSupply
{
  String  Device;
  public powerAdapter(String DeviceType)
  {
    this.Device=DeviceType;
  }
  public int converter()
  {
    if(this.Device.equals("Laptop"))
      return (powervolt/40);
    else if(this.Device.equals("mobile"))
      return (powervolt/20);
    else
      return (powervolt/60);
  }
  
}

  public class AdapterPatternDemo
  {
    public static void main()
    {
      powerAdapter Pa = new powerAdapter("Laptop");
      int Charging= Pa.converter();
      System.out.println("Chargin the device Succesfully,with "+Charging+" volts power supply");
    }
  }

Scenario
         Food ordering Process  

public class Inventory {
public String checkInventory(String OrderId) {
    return "Inventory checked";
}
}

public class Payment {
public String deductPayment(String orderID) {
    return "Payment deducted successfully";
}
}


public class OrderFacade {
private Payment pymt = new Payment();
private Inventory inventry = new Inventory();

public void placeOrder(String orderId) {
    String step1 = inventry.checkInventory(orderId);
    String step2 = pymt.deductPayment(orderId);
    System.out
            .println("Following steps completed:" + step1
                    + " & " + step2);
   }
}

public class Client {
       public static void main(String args[]){
         OrderFacade orderFacade = new OrderFacade();
         orderFacade.placeOrder("OR123456");
         System.out.println("Order processing completed");
       }
  }

Real-Time Examples

Facade 

Let us conside a food ordering system as an example because
Facade hides the complexities of the system and provides an interface to the client from where the client can access the system.
.Checking inventory
.accepting payment
.details of the customer
and many more

Adpater

Imagine there are two people one can speak English and other speaks German. Therefore, there is no way they can communicate. Then they find another person who speaks both the language who helps them communicate.






